---
title: "Calculator App in Android Studio(3)"
description: >-
    안드로이드 스튜디오를 이용하여 계산기 앱 만들기 프로젝트
    MainAcitivity.kt 
    Infix -> Postfix 알고리즘 

date: 2025-08-31 01:00
author: sio2
categories: [Android Studio, Calculator]
tags: [Android Studio, Calculator]
---


# 실행 화면 
갤럭시 S23+ 실행 화면

![Calculator_실행화면01](/assets/img/Calculator/calculator02.gif) 
<br />
![Calculator_실행화면02](/assets/img/Calculator/calculator03.gif) 

<br />
<br />
<br /> 


# 코드 해설
---

## **onCreate 함수** 
### 1. solutionTV, resultTV 초기화 
``` 
solutionTV = findViewById(R.id.solution_tv)
resultTV = findViewById(R.id.result_tv)
```

### 2. 숫자 및 연산자 버튼 초기화 
```
        val buttonsIds = listOf(
            R.id.button_0, R.id.button_1, R.id.button_2, ....
            R.id.button_openBracket, R.id.button_closeBracket, ....
        )

        for (id in buttonsIds) {
            val button = findViewById<Button>(id)
            button.setOnClickListener {
                val text = button.text.toString()
                appendToExpression(text)
            }
        }
``` 

### 3. AC 버튼과 CE 버튼 
```
        // AC 버튼 - 입력값, 결과값 모두 삭제 
        val acButton = findViewById<Button>(R.id.button_ac)
        acButton.setOnClickListener {
            solutionTV.text = ""
            resultTV.text = "0"
        }

        // CE 버튼 - 입력 마지막 글자 삭제
        val ceButton = findViewById<Button>(R.id.button_ce)
        ceButton.setOnClickListener {
            val text = solutionTV.text.toString()
            if(text.isNotEmpty()){
                solutionTV.text = text.substring(0, text.length - 1)
            }
        }
```

### 4. = 버튼 
``` 
        // = 버튼
        val equalsButton = findViewById<Button>(R.id.button_equals)
        equalsButton.setOnClickListener {
            val expression = solutionTV.text.toString()
            try {
                val postfix = infixToPostfix(expression)
                val result = evaluatePostfix(postfix)
                resultTV.text = if (result % 1 == 0.0) result.toInt().toString() else result.toString()
            } catch (e: Exception) {
                resultTV.text = "Error"
            }
        }
```
- 현재 입력된 수식을 postfix로 변환 
- postfix 식을 바탕으로 계산 
- 계산된 결과값을 출력 


--------

## **infixToPostfix 함수** 
```
    private fun infixToPostfix(expression: String): List<String> {
        val output = mutableListOf<String>()
        val stack = _root_ide_package_.java.util.Stack<String>()
        val tokens = tokenize(expression)

        for (token in tokens) {
            when {
                token.toDoubleOrNull() != null -> output.add(token) // 숫자면 출력
                token == "(" -> stack.push(token)
                token == ")" -> {
                    while (stack.isNotEmpty() && stack.peek() != "(") {
                        output.add(stack.pop())
                    }
                    if (stack.isNotEmpty() && stack.peek() == "(") stack.pop()
                }
                else -> {
                    while (stack.isNotEmpty() && precedence(stack.peek()) >= precedence(token)) {
                        output.add(stack.pop())
                    }
                    stack.push(token)
                }
            }
        }
        while (stack.isNotEmpty()) output.add(stack.pop())
        return output
    }
```
1. 숫자는 'token.toDoubleOrNUll() != null'에 따라 바로 output에 추가 -> 숫자는 순서만 지키면 되기 때문
2. '('가 등장하면 이후에 나오는 연산자들은 ')'가 나오기 전까지 스택에 push 
3. ')'가 token으로 나오면 스택에서 '('가 나올 때까지 output에 추가 -> 그런 다음 '('는 버림 
4. 스택의 top에 자신보다 우선순위가 높거나 같은 연산자가 있으면 그 연산자들을 모두 pop -> output에 추가 

----

## **evaluatePostfix 함수** 
``` 
    private fun evaluatePostfix(postfix: List<String>): Double {
        val stack = Stack<Double>()
        for (token in postfix) {
            val num = token.toDoubleOrNull()
            if (num != null) {
                stack.push(num)
            } else {
                val b = stack.pop()
                val a = stack.pop()
                val res = when (token) {
                    "+" -> a + b
                    "-" -> a - b
                    "*" -> a * b
                    "/" -> a / b
                    else -> 0.0
                }
                stack.push(res)
            }
        }
        return stack.pop()
    }
``` 
1. 현재 token이 숫자라면 stack에 push
2. 숫자가 아니라면 연산자로 간수 
    - b = 먼저 꺼낸 숫자 / a = 나중에 꺼낸 숫자
    - when(token)의 연산자에 따라서 계산
3. 2의 계산 결과를 push 
4. 모든 토큰 처리 후 최종 결과 반환

----

## **tokenize 함수**
```
    private fun tokenize(expr: String): List<String> {
        val tokens = mutableListOf<String>()
        var number = ""
        var prev: String? = null

        for (c in expr) {
            if (c.isDigit() || c == '.') {
                number += c
            } else {
                if (number.isNotEmpty()) {
                    tokens.add(number)
                    number = ""
                }
                // unary minus 처리 (맨 처음 또는 '(' 뒤에 나오는 '-')
                if (c == '-' && (prev == null || prev in listOf("(", "+", "-", "*", "/"))) {
                    number = "-" // unary라면 숫자에 부호 붙임
                } else {
                    tokens.add(c.toString())
                }
            }
            prev = c.toString()
        }
        if (number.isNotEmpty()) tokens.add(number)
        return tokens
    }
```
1. 숫자나 소수점이라면 number에 누적
2. 숫자가 아닌 문자가 나오면
    - 만약 number에 값이 있으면 그걸 token에 추가하고 number 초기화 
    - 이후 현재 문자가 '-'이고, 이전 문자가 없거나 다른 연산자 중 하나이면 단항 음수로 판단 -> 다음에 오는 숫자에 '-'가 붙음 
    - 그렇지 않으면 현재 문자 그대로 토큰에 추가 
-----

<br />

이상 Calculator Project 끝!   
github 놀러오세용🤗🐳 
[Calculator Github](https://github.com/choisio2/Calculator_Project.git)

<br /><br /><br />
 
